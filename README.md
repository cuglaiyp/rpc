# 简易 rpc 框架 :rocket:
仿照Go 语言官方的标准库 net/rpc，进行开发，并在此基础上，新增了协议交换、注册中心、服务发现、负载均衡、超时处理等特性。



### 主要特点：
- :hammer: 编解码部分除了实现了 Json、Gob 格式，还实现了自定义的 TLV 编码，支持 int 类、uint类、byte、string、struct等常见类型
- :dart: 负载均衡采用了客户端负载均衡策略，实现了随机、轮询和一致性 Hash 三种算法
- :cloud: 实现了简易的注册中心和心跳机制，同时支持了 Zookeeper 和 Etcd 
- :clock10: 使用 time.After 和 select-chan 机制为客户端连接、服务端处理添加了超时处理机制



### 客户端

#### 客户端的创建

1. 请求进来，到达负载均衡客户端；
2. 负载均衡客户端调用服务发现模块获取一个服务的[ip:port]，服务发现模块通过自己的负载均衡策略给负载均衡客户端返回一个[ip:port]，负载均衡客户端通过这个[ip:port]从自身维护的map中取出与之对应的通信客户端。
3. 判断通信客户端是否关闭或者为空，如果是，则移除并重新创建通信客户端。创建通信客户端的方法是支持多协议的，通过 ip 上的协议名称，传入不同的客户端创建策略进行创建。具体来说，创建一个通信客户端分为以下几步：
   1. 调用库函数 net.DialTimeout 得到一个conn
   2. 启用一个新协程，使用conn去调用客户端创建策略方法，并给这个协程设置超时（select chan + time after）
   3. 客户端创建策略方法会根据自身的协议去创建一个客户端，如果再超时时间内会把这个客户端通过channel返回给父协程。客户端的创建策略目前有两种：
      - HTTP 客户端策略：会与服务端进行一次http的 CONNECT 通信，使得这个 conn 能够被服务端劫持，接着再去创建一个 rpc 客户端。从而使得这个连接既可以传输 HTTP 请求，又可以传输我们自定义的 rpc 消息格式；
      - rpc 客户端策略：使用Json格式的数据与服务端进行两次握手，从而与服务器协商用户自定好的编解码器，并且启动一个接收协程。

4. 创建好的通信客户端会被返回给负载均衡客户端，用对应[ip:port]存起来，以便复用。然后使用这个通信客户端进行rpc调用

#### 客户端调用

1. 通信客户端会将这次的调用请求封装成 call，call里面包含了唯一标识（seq）、请求的方法、参数、返回值以及一个chan，并且使用唯一标识，在自己的map中维护这个call
2. 之后，会将call中的具体的参数封装成协议要求的格式（header + body：header 包括 seq、服务方法名、错误；body为参数），通过编码器写给服务端。这个过程通过 call 中的 chan 实现了异步调用，发送完消息之后，直接返回这个  call。

#### 客户端接收结果

1. 在创建通信客户端的时候，除了与服务端协商编码，还会启动一个接收协程。
2. 接收协程死循环接收服务端的响应。
3. 接收协程接在收到服务返回的消息后，会将返回结果解析成 call，call 中的返回值字段即用来承载服务端的处理结果。收到消息后，会给这个call 中的 chan 字段写入“处理完成”的消息，即通知持有这个 call 的用户，结果已经接收到了，可以进行下一步操作了。处理完成之后，会从通信客户端中移除这个call（因为它已经完成了它的使命）
4. 在这个循环过程中，如果发现了消息解析错误或者网络io错误，会跳出这个循环，然后中断这个通信客户端中所有 call，告诉它们有错误发生（因为前面的解析或者网络错误，会导致后面的所有 call 都出现问题，那么没必要再等服务器的消息了）

---



### 服务端

#### 接收连接

1. 在主协程中死循环 Accept，每收到一个连接，会启动一个新的协程去处理这个连接
2. 一个新的连接进来，要建立可用的rpc通信，需要进行编码协商（这也是新建通信客户端时候所做的事）。那么服务端在连接处理协程中，就需要先处理这个事情，然后才能rpc通信。具体分为以下几个步骤：
   1. 解析编码协商报文
   2. 判断魔术
   3. 根据编码协商报文中的编码字段创建响应编解码器
   4. 响应客户端，通知协商成功（客户端接收到成功响应之后，才能发送请求，防止粘包）

#### 处理连接

1. 编码协商成功后，连接处理协程会进入死循环接收该连接中的报文（因为一次连接中可以有多次调用（header+body），那么需要尽力而为）
2. 因为一个连接可能有多次调用，而考虑到这些调用是可以并发进行，连接处理协程在解析一个header+body对之后，就会启动一个请求处理协程，去处理这个请求，执行相应的方法。并且如果某一次读取解析header+body出现了错误，那么就需要跳出循环，关闭这个连接，而此时前面还有header+body的调用正在请求处理协程中进行处理，所以不能立即关闭连接，那么就引入了 WaitGroup 等待所有请求处理协程处理完毕之后再关闭连接
3. 执行一个方法的时间可长可短，在请求处理协程中，也采用了（协程调用 + select chan + time after 的超时机制）
4. 因为调用完后，写给客户端的返回值也是header+body，那么就需要保证在这个连接中header+body是成对写入的，不能出现交织，所以需要用锁控制header+body写回的原子性。

#### 协程模型

Acceptor --> ConnectionHandler --> RequestHandler

​			1    :                   M                   :              N

---



### 服务


1. 因为客户端的请求是 service.method，所以我们分别定义了 service 结构体和 methodType 结构体分别用来保存“一个用来提供服务的结构体”和“其方法被调用所需要“的各项信息
2. service 对象代表着一个提供服务的对象，methodType 对象代表着这个提供服务的对象的一个方法。所以 service 以 map 持有多个 methodType。
3. 提供了将一个结构体对象转变成 service对象，其中的合规方法转变成 methodType 的函数。（合规的方法的签名只能有两个入参，前一个代表参数，后一个代表返回值，和一个错误返回值）
4. 将 service 集成进 Server，使得 Server能够注册 service，持有多个 service，并且在处理请求时，能够调用到对应 service 的 method 上

---



### 注册中心

#### 简易注册中心

1. 这个注册中心维护了一个 [服务器地址 -> 服务器地址 + 该服务上一次的心跳时间] 的 map，并且通过实现 http.Handler 接口，对外提供 Http 服务，这样每个服务器可以通过 POST 请求发送心跳、服务发现模块通过 GET 请求拉取所有可用服务器的地址。
2. 注册中心在响应服务发现模块的GET请求时，会遍历一遍自己维护的服务列表，剔除掉已经超时的服务，然后通过 HTTP 自定义头，返回所有存活的服务地址。
3. 此外，还暴露了对外的 Heartbeat 函数，使得服务可以使用该函数向指定注册中心发送指定服务的心跳

#### Etcd 注册中心

1. 由于 Etcd 注册中心是另起的 Etcd 服务，所以在使用这个注册中心时，需要使用自己封装的 Etcd 注册中心客户端与 Etcd 通信。
2. Etcd 注册中心客户端会与 Etcd 创建一个租约，并将服务器地址存入该租约。同时，为这个租约开启自动续租，也就是保持心跳。自动续租之后，需要开启一个协程，消费掉自动续租产生消息，避免阻塞

#### Zookeeper 注册中心

1. 由于 Zookeeper 注册中心是另起的 Zookeeper 服务，所以在使用这个注册中心时，需要使用自己封装的 Zookeeper 注册中心客户端与 Zookeeper 通信。
2. 由于 Zookeeper 存在临时结点这个结构，所以我们在将服务地址推送进 Zookeeper 中之后，不要手动保持心跳，Zookeeper 会自己根据超时时间检测 Zookeeper 注册中心客户端的存活情况

---



### 服务发现

#### 简易服务发现模块

1. 简易服务发送模块，内部维护了从注册中心全量拉取的服务器地址
2. 并且在每次 Get 服务器地址时，会使用 Refresh 方法根据设定好的超时时间，判断是否要去注册中心全量拉取一次
3. 更新完注册中心地址后，会通过设定好的负载均衡算法，从服务器地址列表中返回一个选中的服务器地址给通信客户端

#### Etcd 服务发现模块

1. Etcd 服务发现模块也即一个 Etcd 的客户端，并且继承了简易服务发现模块，重写了简易服务发现模块的 Refresh 方法。这样每次在刷新的时候就回去 Etcd 注册中心拉取全量的服务地址
2. Etcd 服务发现模块在创建的时候，除了会与 Etcd 注册中心连接，还会开启一个 Watcher 协程，监听 Etcd 指定前缀的 key（也即服务器地址）有无变化，从而可以及时更新本地服务器地址列表。Etcd 注册中心的通知，会告知客户端哪些 key 发生变化，从而做到精细控制

#### Zookeeper 服务发现模块

1. Zookeeper 服务发现模块也即一个 Zookeeper 的客户端，并且继承了简易服务发现模块，重写了简易服务发现模块的 Refresh 方法。这样每次在刷新的时候就回去 Zookeeper 注册中心拉取全量的服务地址
2. Zookeeper 服务发现模块在创建的时候，除了会与 Zookeeper 注册中心连接，还会开启一个 Watcher 协程，监听 Zookeeper 指定父结点的子结点（也即服务器地址）有无变化，从而可以及时更新本地服务器地址列表。Zookeeper 注册中心的通知只会通知变化，并且用完失效，从而需要循环监听





